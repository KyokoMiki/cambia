#[macro_use]
extern crate lazy_static;

pub mod extract;
pub mod parser;
pub mod translate;
pub mod integrity;
pub mod toc;
pub mod track;
pub mod util;
pub mod error;
pub mod evaluate;
pub mod response;
pub mod server;
pub mod drive;

use std::{fs::OpenOptions, io::Read};

use error::CambiaError;
use evaluate::{EvaluationCombined, Evaluator, gazelle_evaluate::ops_evaluate::OpsEvaluator, cambia_evaluate::CambiaEvaluator};
use parser::{eac_parser::EacParser, ParserCombined, xld_parser::XldParser, whipper_parser::WhipperParser, ParsedLogCombined};
use response::CambiaResponse;
use server::CambiaServer;
use simple_text_decode::DecodedText;

use figlet_rs::FIGfont;
use clap::Parser;
use translate::TranslatorCombined;

/// Program to parse log files generated by various CD ripping software
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Path to the log file
    #[arg(short, long)]
    path: Option<String>,
    /// Enable server mode
    #[arg(short, long)]
    server: bool,
}

fn first_line(string: &str) -> &str {
    string.lines().next().unwrap()
}

fn parse_file(filepath: &str) {
    let mut raw: Vec<u8> = Vec::new();

    let mut fh = OpenOptions::new().read(true).open(filepath).expect(
        "Could not open file",
    );

    fh.read_to_end(&mut raw).expect(
        "Could not read file"
    );

    if let Ok(parsed) = parse_log_bytes(raw) {
        println!("{}", serde_json::to_string(&parsed).unwrap());
    }
}

fn parse_log_bytes(log_raw: Vec<u8>) -> Result<CambiaResponse, CambiaError> {
    if log_raw.is_empty() {
        return Err(CambiaError::new("Empty request body"));
    }

    let encoded_log = DecodedText::new(log_raw).unwrap_or_default();
    
    let parsed_logs: ParsedLogCombined = match first_line(&encoded_log.text) {
        eac if eac.contains("Exact Audio Copy") || eac.contains("EAC") => EacParser::new(encoded_log).parse_combined(),
        xld if xld.contains("X Lossless Decoder version") => XldParser::new(encoded_log).parse_combined(),
        whipper if whipper.contains("Log created by: whipper") => WhipperParser::new(encoded_log).parse_combined(),
        _ => {
            return Err(CambiaError::new("Unsupported file."));
        }
    };

    let mut ops_evaluator: OpsEvaluator = OpsEvaluator::new();
    let ops_evaluation: EvaluationCombined = ops_evaluator.evaluate_combined(&parsed_logs);

    let mut cambia_evaluator = CambiaEvaluator::new();
    let cambia_evaluation: EvaluationCombined = cambia_evaluator.evaluate_combined(&parsed_logs);

    Ok(CambiaResponse::new(parsed_logs, vec![ops_evaluation, cambia_evaluation]))
}

fn translate_log_bytes(log_raw: Vec<u8>) -> Result<String, CambiaError> {
    if log_raw.is_empty() {
        return Err(CambiaError::new("Empty request body"));
    }

    let encoded_log = DecodedText::new(log_raw).unwrap_or_default();
    
    let translated_logs: String = match first_line(&encoded_log.text) {
        eac if eac.contains("Exact Audio Copy") || eac.contains("EAC") => EacParser::new(encoded_log).translate_combined(),
        xld if xld.contains("X Lossless Decoder version") => encoded_log.text,
        whipper if whipper.contains("Log created by: whipper") => encoded_log.text,
        _ => {
            return Err(CambiaError::new("Unsupported file."));
        }
    };

    Ok(translated_logs)
}

pub fn parse_ws_request(mut ws_body: Vec<u8>) -> Result<CambiaResponse, CambiaError> {
    // xxH64 is 8 bytes
    if ws_body.len() < 8 {
        return Err(CambiaError::new("WS message length too small"));
    }
    
    let log_bytes = ws_body.split_off(8);
    match parse_log_bytes(log_bytes) {
        Ok(mut res) => {
            res.id = ws_body;
            Ok(res)
        },
        other => other,
    }
}

#[tokio::main]
async fn main() {
    let args = Args::parse();
    
    if args.path.is_some() {
        parse_file(&args.path.unwrap()[..]);
    } else {
        let font = FIGfont::standard().unwrap();
        println!("{}", font.convert("cambia").unwrap());
        CambiaServer::start().await;
    }
}
